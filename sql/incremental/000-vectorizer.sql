
create table ai.vectorizer
( id int not null primary key generated by default as identity
, asynchronous bool not null default true
, external bool not null default true
, source_schema name not null
, source_table name not null
, source_pk jsonb not null
, target_schema name not null
, target_table name not null
, target_column name not null
, queue_schema name
, queue_table name
, config jsonb not null
, unique (target_schema, target_table)
, check (case when not asynchronous then not external else true end)
);
perform pg_catalog.pg_extension_config_dump('ai.vectorizer'::pg_catalog.regclass, '');
perform pg_catalog.pg_extension_config_dump('ai.vectorizer_id_seq'::pg_catalog.regclass, '');

create table ai.vectorizer_request
( id bigint not null primary key generated by default as identity
, vectorizer_id int not null references ai.vectorizer(id) on delete cascade
, args jsonb not null
, status text not null default 'pending' check (status in ('pending', 'running'))
, requested timestamptz not null default now()
, started timestamptz
, check (case when status = 'pending' then started is null when status = 'running' then started is not null end)
);
perform pg_catalog.pg_extension_config_dump('ai.vectorizer_request'::pg_catalog.regclass, '');
perform pg_catalog.pg_extension_config_dump('ai.vectorizer_request_id_seq'::pg_catalog.regclass, '');

create index on ai.vectorizer_request (vectorizer_id, requested desc) where (status = 'pending');
create index on ai.vectorizer_request (vectorizer_id, started desc) where (status = 'running');
